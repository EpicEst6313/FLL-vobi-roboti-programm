import motor, motor_pair, runloop, color_sensor
from hub import port, button, light_matrix

varvi_andm = {}
missiooni_arv = 3
kalib_tehtud = False
 # sentimeetrites ratta diameeter
RATTA_D = 5.6
RATASTE_VAH_KAUGUS = 11.3 #11.3 sentimeetrites rataste vaheline kaugus
motor_pair.pair(motor_pair.PAIR_1, port.B, port.A)

# kasutame selleks et arvutada 4dimensioonis asuva kolmnurga hüpotenuusi
def kaugus_ruudus(cal_punkt, moot_puntk):
    kaugus_r = []
    for i in range(4):
        kaugus_r.append((moot_puntk[i] - cal_punkt[i])**2)
    return sum(kaugus_r)

# esimese mootori paari sõitmis def et mul oleks lihtsam mootoreid liikuma panna kuna spike asi on kolmerinevat kutsungit mis ei meeldinud mulle
async def paar1_soitmine(pooramine, kiirus, kraadid, stop=False, aeglustus=750):
    if stop:
        motor_pair.stop(motor_pair.PAIR_1)
    if kraadid == 0:
        motor_pair.move(motor_pair.PAIR_1, pooramine, velocity=kiirus)
    else:
        await motor_pair.move_for_degrees(motor_pair.PAIR_1, round(kraadid/0.6),pooramine,velocity=kiirus ,acceleration=750, deceleration=aeglustus)
        """
        motor.run_for_degrees(port.B, round(kraadid/0.6),kiirus ,acceleration=1500, deceleration=1500)
        await motor.run_for_degrees(port.A,round(kraadid/0.6),kiirus*-1 ,acceleration=1500, deceleration=1500)"""

# ksutab mootori kraade et pöörata võimalikult täpselt
# 100% tähendab et parem rattas pöörab ainsan, 50% tähendab et mõlemad põõravad ja 0% tähendab et vasak rattas pöörab(poor_prots_ratas_vask_par)
async def pooramine(poor_kraadid, vas_mot=50, par_mot=50, kiirendus=500, aeglustus=500, kiirus=1050):
    """
    arvutab por_kraadide järgi mitu kraadi peavad mootorid liikuma soovitud nurga saamiseks

        :positiivne pooramine on vasakule!!!
        :protsentide jaotamine kahtlane 50 50 töötab kõige paremini
        :arvutab alguses mitu kraadi kumbki mootor pöörama peab
        :pärast kontrollib kas on 50 50 pööre kui on siis paneb tegema
        :kontrollib kui oalju on vaja vasakut ja paremat rattast pöörata ja arvutab aja järgi välja nende pöörde kiiruse (pikem pöörde tegev rattas pöörab ette antud kiiruse järgi)
        :kui mingil põhjusel on vasaku ja parema ratta % töötamine valesti antud siis viskab ette vea teate
    """

    # Arvuta rataste pööramise kraadides
    pöörde_pikkus = 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679*2*RATASTE_VAH_KAUGUS*(poor_kraadid/360)
    mootori_kraadid = pöörde_pikkus/(3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679*RATTA_D*(1/360))
    parem_ratta_poor = (mootori_kraadid*par_mot/100)/0.6
    vasak_ratta_poor = (mootori_kraadid*vas_mot/100)/0.6

    #kui mõlemad on 50 50 siis paneb lihtsalt liikuma
    if(vas_mot == 50 and par_mot == 50):
        motor.run_for_degrees(port.B, round(parem_ratta_poor),kiirus, acceleration=kiirendus, deceleration=aeglustus)
        await motor.run_for_degrees(port.A, round(vasak_ratta_poor),kiirus, acceleration=kiirendus, deceleration=aeglustus)

    # kui vasak mootor pöörab % vähem siis arvutab parema mootori järgi kiiruse ja kontrollib et mõlema % oleks 100%
    elif(vas_mot < 50 and par_mot > 50 and vas_mot + par_mot == 100):
        par_mot_aeg = parem_ratta_poor/kiirus
        vasak_ratta_kiirus = vasak_ratta_poor/par_mot_aeg
        motor.run_for_degrees(port.A, round(vasak_ratta_poor),round(vasak_ratta_kiirus), acceleration=kiirendus, deceleration=aeglustus)
        await motor.run_for_degrees(port.B, round(parem_ratta_poor),kiirus, acceleration=kiirendus, deceleration=aeglustus)

    # kui parem mootor pöörab % vähem siis arvutab parema mootori järgi kiiruse
    elif(vas_mot > 50 and par_mot < 50 and vas_mot + par_mot == 100):
        vas_mot_aeg = vasak_ratta_poor/kiirus
        parem_ratta_kiirus = parem_ratta_poor/vas_mot_aeg
        motor.run_for_degrees(port.B, round(parem_ratta_poor),round(parem_ratta_kiirus), acceleration=kiirendus, deceleration=aeglustus)
        await motor.run_for_degrees(port.A, round(vasak_ratta_poor),kiirus, acceleration=kiirendus, deceleration=aeglustus)

    # kui % on valesti pandud ja mootorid ei saa pöörata nt on 46 ja 27
    else:
        print("võimsused valesti jaotatud")

async def varvi_kalib():
    global varvi_andm, kalib_tehtud
    for i in range(1, missiooni_arv+1):
        light_matrix.write(str(i))
        while not button.pressed(button.LEFT):
            await runloop.sleep_ms(10)
        while button.pressed(button.LEFT):
            await runloop.sleep_ms(10)
        punane_kogu_sum = 0
        roheline_kogu_sum = 0
        sinine_kogu_sum = 0
        tugevus_kogu_sum = 0
        for j in range(10):
            punane, roheline, sinine, tugevus = color_sensor.rgbi(port.D)
            punane_kogu_sum += punane
            roheline_kogu_sum += roheline
            sinine_kogu_sum += sinine
            tugevus_kogu_sum += tugevus
            await runloop.sleep_ms(100)

        punane_kesk = punane_kogu_sum/10
        roheline_kesk = roheline_kogu_sum/10
        sinine_kesk = sinine_kogu_sum/10
        tugevus_kesk = tugevus_kogu_sum/10
        varvi_andm[i] = [punane_kesk,roheline_kesk ,sinine_kesk ,tugevus_kesk]

    light_matrix.write("ok?")
    while True:
        if button.pressed(button.RIGHT):
            kalib_tehtud = True
            break
        elif button.pressed(button.LEFT):
            kalib_tehtud = False
            break
    while button.pressed(button.LEFT) or button.pressed(button.RIGHT):
        await runloop.sleep_ms(10)

# tuvastab mis värvi moodul on peal kasutab vektori arvutust et teha kindlaks milline mooduli värvi vektori tulemus on lähim
def varvi_tuvastus():
    varv = color_sensor.rgbi(port.D)
    ruut_vaartused = []
    for i in varvi_andm.keys():
        ruut_vaartused.append(kaugus_ruudus(varvi_andm[i], varv))

    if(min(ruut_vaartused)<(50*50+50*50+50*50+50*50)):
        return ruut_vaartused.index(min(ruut_vaartused))+1
    else:
        return 0

async def soit_1():
    await paar1_soitmine(0, 1050, 200)
    await pooramine(42)
    #algussättimne
    await paar1_soitmine(0, 1050, 1075)
    await motor.run_for_degrees(port.F, 100, 1000)
    #await paar1_soitmine(0, 800, -100)
    await pooramine(-96)
    #lineup haile
    await paar1_soitmine(0, 1050, 650)
    await paar1_soitmine(0, 1050, -415)
    #lineup korallile
    await pooramine(139)
    await paar1_soitmine(0, 1050, -575)
    await motor.run_for_degrees(port.E, -100, 1000)
    await runloop.sleep_ms(500)
    await paar1_soitmine(0, 1050, 300)
    await pooramine(-55)
    await paar1_soitmine(0, 1050, -1500)
    #paneb mootori teiseks sõiduks valmis
    motor.run_to_absolute_position(port.E, 300, -300)
    motor.stop(port.E)
async def soit_2():
    motor.stop(port.E)
    #läheb paadi purje ja aarde laegast varastama
    await paar1_soitmine(0, 1050, 910)
    await pooramine(47)
    await paar1_soitmine(0, 1050, 300)
    await pooramine(47)
    await paar1_soitmine(0, 950, 950, aeglustus=300)
    await motor.run_for_degrees(port.F, 105, 350)
    await runloop.sleep_ms(1000)
    await motor.run_for_degrees(port.E, -75, 500)
    await runloop.sleep_ms(1000)
    await motor.run_for_degrees(port.E, 60, 300)
    await paar1_soitmine(-13, -1050, 1750)

async def soit_3():
    await paar1_soitmine(0, 1050, 100)
    await pooramine(65)
    await paar1_soitmine(0, 1050, 1400)
    await paar1_soitmine(0, 1050, -350)
    await pooramine(45)
    await paar1_soitmine(0, 1050, 1800)
    await pooramine(50)
    await paar1_soitmine(0, 1050, -700)
    await paar1_soitmine(0, 1050, 1100)

async def soit_4():
    await paar1_soitmine(0, 1050, 200)
    await pooramine(-54)
    await paar1_soitmine(2, 1050, 2000)
    await pooramine(58)
    await paar1_soitmine(0, 1050, 800)
    await paar1_soitmine(0, 1050, -530)

async def testid():
    await pooramine(90)

# peamine meetod mis kasutab teisi meetodeid et lahendada ülessandeid vaatab kas värvid on kalibreeritud ja kui ei ole siis kalibreerib ära
async def soidu_tuvastus():
    while True:
        #kontrollib kas on kalibreeritud
        if kalib_tehtud:
            #kontrollib milline missioon on või kas moodul puudub
            if (varvi_tuvastus() == 0):
                    light_matrix.write(str(0))
                    await runloop.sleep_ms(20)
            if (varvi_tuvastus() == 1):
                light_matrix.write(str(1))
                if(button.pressed(button.LEFT)):
                    await soit_1()
            if (varvi_tuvastus() == 2):
                    light_matrix.write(str(2))
                    if(button.pressed(button.LEFT)):
                        await soit_2()
            if (varvi_tuvastus() == 3):
                    light_matrix.write(str(3))
                    if(button.pressed(button.LEFT)):
                        print('veel üks sõit?')
            if (varvi_tuvastus() == 4):
                    light_matrix.write(str(4))
                    if(button.pressed(button.LEFT)):
                        print('veel üks soit?')
            if (varvi_tuvastus() == 5):
                    light_matrix.write(str(5))
                    if(button.pressed(button.LEFT)):
                        print('veel üks soit?')
        # kui ei ole kalibreeritud siis kalibreerib
        else:
            await varvi_kalib()

#motor.run_to_absolute_position(port.E, 315, -300)
#runloop.run(paar1_soitmine(0, -1050, -4500))
runloop.run(soit_4())
